\chapter{VR Deployment Configuration}
\label{app:vr_implementation}

This appendix provides detailed technical specifications for the Meta Quest 3 virtual reality deployment described in Section~\ref{subsec:vr_implementation}, implementing the spatial learning and immersive presence principles outlined in Section~\ref{sec:ar_vr_review}. All build settings, input mappings, rendering configurations, and scene architecture details are verified against the Unity project configuration files.

\section{Quest 3 Android Build Configuration}
\label{app:vr_android}

The application deploys to Meta Quest 3 through Unity's Android build pipeline with OpenXR integration. Table~\ref{tab:android_build} documents the core build settings from \texttt{ProjectSettings.asset}.

\begin{table}[h]
\centering
\caption{Android Build Configuration}
\label{tab:android_build}
\begin{tabular}{ll}
\hline
\textbf{Setting} & \textbf{Value} \\
\hline
Unity Version & 6000.0.47f1 \\
Meta XR SDK & 78.0.0 \\
Minimum SDK Version & 32 (Android 12L) \\
Target SDK Version & 32 (Android 12L) \\
Target Architecture & ARMv7 (value: 2) \\
Graphics API & OpenGL ES 3.0 \\
XR Plugin & OVRPlugin (Oculus SDK) \\
Stereo Rendering Mode & Single Pass Instanced (value: 2) \\
Target Device & Meta Quest 3 \\
\hline
\end{tabular}
\end{table}

\subsection{SDK Version Rationale}

Android API level 32 (Android 12L) enables:

\begin{itemize}
\item Quest 3's inside-out tracking system (6DOF head and controller tracking)
\item Oculus runtime features (Guardian boundary, passthrough API access)
\item Hand tracking capabilities (though not actively used in this application)
\item Performance optimizations for Snapdragon XR2 Gen 2 processor
\end{itemize}

\subsection{Stereo Rendering Pipeline}

Single-pass instanced rendering (value 2 in \texttt{ProjectSettings.asset} line 49) reduces CPU overhead by rendering both eye views in a single draw call. This technique:

\begin{itemize}
\item Halves per-frame CPU work compared to multi-pass rendering
\item Maintains Quest 3's 90 Hz refresh rate target
\item Reduces GPU state changes and draw call overhead
\item Critical for mobile VR performance on battery-powered hardware
\end{itemize}

\subsection{Build Index Scene Configuration}

Table~\ref{tab:scene_build} documents the scene inclusion from \texttt{EditorBuildSettings.asset}.

\begin{table}[h]
\centering
\caption{Scene Build Index Configuration}
\label{tab:scene_build}
\begin{tabular}{rlr}
\hline
\textbf{Index} & \textbf{Scene Name} & \textbf{File Size} \\
\hline
0 & Hub.unity & 85 KB \\
1 & ISS.unity & 65 KB \\
2 & Hubble.unity & 66 KB \\
3 & Voyager.unity & 62 KB \\
4 & ARHub.unity (experimental) & 61 KB \\
\hline
\end{tabular}
\end{table}

Scene index 0 (Hub) loads at application startup. Scene transitions occur through \texttt{SceneManager.LoadSceneAsync()} with scene names or indices.

\section{Input System Implementation}
\label{app:vr_input}

Controller input integrates Oculus Touch controllers through the OVR Input API. Table~\ref{tab:controller_mapping} documents the input bindings used in the application.

\begin{table}[h]
\centering
\caption{Controller Input Mapping}
\label{tab:controller_mapping}
\begin{tabular}{lll}
\hline
\textbf{Action} & \textbf{Desktop} & \textbf{Quest 3 VR} \\
\hline
Push-to-talk (voice) & Space key & Right controller A button \\
Confirm/Select & Enter key & Right controller trigger \\
Cancel/Back & Escape key & Left controller B button \\
\hline
\end{tabular}
\end{table}

\subsection{Push-to-Talk Implementation}

The \texttt{PromptConsole.Update()} method (line 283) detects the right controller's A button through OVR Input API:

\begin{verbatim}
bool aButtonPressed = OVRInput.Get(
    OVRInput.Button.One,
    OVRInput.Controller.RTouch
);
\end{verbatim}

\subsubsection*{State Debouncing} The system tracks previous button state (\texttt{\_previousAButtonState}) to detect rising edge transitions, preventing accidental double-triggers from single button presses. This ensures one recording session per button press/release cycle.

\subsection{Desktop Testing Mode}

Desktop mode falls back to keyboard input through Unity's legacy Input system:

\begin{verbatim}
bool spacePressed = Input.GetKeyDown(KeyCode.Space);
\end{verbatim}

This enables development iteration without VR hardware, maintaining identical functionality across desktop testing and Quest 3 deployment.

\subsection{VR Mode Detection}

The \texttt{StaticVRCameraAligner} class (89 lines) detects VR mode at startup through:

\begin{verbatim}
bool isVR = XRSettings.isDeviceActive;
\end{verbatim}

When \texttt{isDeviceActive} returns \texttt{true}, the system locates the \texttt{OVRCameraRig} component via \texttt{FindObjectOfType<OVRCameraRig>()} and configures VR-specific camera settings.

\section{Camera and Rendering Configuration}
\label{app:vr_camera}

\subsection{OVRCameraRig Structure}

The Quest 3 camera system follows Oculus SDK conventions. Table~\ref{tab:camera_hierarchy} documents the camera hierarchy.

\begin{table}[h]
\centering
\caption{VR Camera Hierarchy}
\label{tab:camera_hierarchy}
\begin{tabular}{ll}
\hline
\textbf{GameObject} & \textbf{Purpose} \\
\hline
OVRCameraRig & Root container for VR camera system \\
TrackingSpace & Offset container for room-scale tracking \\
CenterEyeAnchor & Head-tracked camera position (stereo) \\
LeftEyeAnchor & Left eye render camera \\
RightEyeAnchor & Right eye render camera \\
LeftHandAnchor & Left controller tracking \\
RightHandAnchor & Right controller tracking \\
\hline
\end{tabular}
\end{table}

\subsection{Near Clip Plane Configuration}

The \texttt{StaticVRCameraAligner} configures the near clip plane to prevent geometry clipping at close range (line 68):

\begin{verbatim}
cam.nearClipPlane = 0.01f; // Unity units
\end{verbatim}

This 0.01 Unity unit near clip (approximately 1.27 cm in physical space with scale compression factor $k = 0.000785$) ensures UI elements positioned within arm's reach remain visible without clipping.

\subsection{Desktop Camera Alignment}

Desktop mode aligns the fallback camera to match VR positioning conventions, ensuring consistent coordinate systems between development and deployment environments. This allows testing of UI positioning and scene layout without VR hardware.

\section{Spatial UI Implementation}
\label{app:vr_ui}

User interface elements render in 3D world space rather than screen overlay to ensure VR readability and depth perception. Table~\ref{tab:ui_rendering} documents the UI rendering configuration.

\begin{table}[h]
\centering
\caption{Spatial UI Rendering Configuration}
\label{tab:ui_rendering}
\begin{tabular}{ll}
\hline
\textbf{Parameter} & \textbf{Value} \\
\hline
Canvas render mode & WorldSpace \\
Canvas size (transition overlay) & 2m × 2m \\
Canvas distance from camera & 1 meter (dynamic) \\
Mission logo size & 512×512 pixels \\
Text component & TextMeshPro \\
Background opacity (UI panels) & 0.7 alpha \\
Sort order (transition canvas) & 100 (renders on top) \\
\hline
\end{tabular}
\end{table}

\subsection{MissionClockUI Pattern}

The \texttt{MissionClockUI} class (74 lines) demonstrates the spatial UI pattern:

\begin{enumerate}
\item Canvas component with \texttt{RenderMode.WorldSpace}
\item TextMeshPro text field positioned in 3D environment
\item CanvasGroup component (line 37) controls opacity without render-to-texture overhead
\item Displays mission elapsed time and simulation speed multiplier
\end{enumerate}

\subsection{Transition Overlay System}

The \texttt{SceneTransitionManager.CreateTransitionUIIfNeeded()} method (lines 729--838) constructs the transition overlay procedurally:

\subsubsection*{Canvas Construction}

\begin{verbatim}
Canvas canvas = canvasObj.AddComponent<Canvas>();
canvas.renderMode = RenderMode.WorldSpace;
canvas.sortingOrder = 100;

RectTransform canvasRect = canvasObj.GetComponent<RectTransform>();
canvasRect.sizeDelta = new Vector2(2f, 2f); // 2m × 2m
\end{verbatim}

\subsubsection*{Dynamic Positioning} The \texttt{LateUpdate()} method (lines 154--180) repositions the canvas 1 meter in front of the camera each frame:

\begin{verbatim}
transitionCanvasTransform.position =
    cachedCameraAnchor.position +
    cachedCameraAnchor.forward * 1f;

transitionCanvasTransform.rotation =
    cachedCameraAnchor.rotation;
\end{verbatim}

This dynamic positioning ensures the overlay remains visible during scene transitions when camera references change, avoiding parenting to scene-specific GameObjects that would be destroyed during \texttt{SceneManager.LoadSceneAsync()}.

\section{Scene Architecture and Persistence}
\label{app:vr_scenes}

The application comprises four navigable scenes sharing common systems through persistent singletons. Table~\ref{tab:scene_components} documents shared components across all scenes.

\begin{table}[h]
\centering
\caption{Common Scene Components}
\label{tab:scene_components}
\begin{tabular}{ll}
\hline
\textbf{Component} & \textbf{Purpose} \\
\hline
OVRCameraRig prefab & VR camera and controller tracking \\
PromptConsole GameObject & Conversational UI and voice input \\
TimeController & Simulation speed management \\
OrbitController & Orbital physics (Hub only) \\
OrbitVisualizer & Trajectory rendering (Hub only) \\
\hline
\end{tabular}
\end{table}

\subsection{Singleton Persistence Mechanism}

The \texttt{SceneTransitionManager} enforces singleton persistence through Unity's \texttt{DontDestroyOnLoad()} mechanism (line 58):

\begin{verbatim}
if (Instance == null) {
    Instance = this;
    DontDestroyOnLoad(gameObject);
}
\end{verbatim}

This ensures the transition UI and conversation context survive scene unloading. Similarly, \texttt{ConversationHistory} persists across transitions, preserving the 10-exchange dialogue window.

\subsection{Asynchronous Scene Loading}

Scene loading occurs through \texttt{SceneManager.LoadSceneAsync()} with deferred activation (line 252):

\begin{verbatim}
AsyncOperation loadOperation =
    SceneManager.LoadSceneAsync(sceneName);
loadOperation.allowSceneActivation = false;

// Load scene in background...

// After 4-second logo animation:
loadOperation.allowSceneActivation = true;
\end{verbatim}

This deferred activation prevents jarring scene pops, allowing smooth fade-out → logo display → scene activation → fade-in transitions.

\section{Performance Optimization}
\label{app:vr_performance}

Performance optimization targets Quest 3's mobile GPU constraints. Table~\ref{tab:performance_targets} documents the performance budget.

\begin{table}[h]
\centering
\caption{Performance Targets for 90 Hz VR}
\label{tab:performance_targets}
\begin{tabular}{lr}
\hline
\textbf{Metric} & \textbf{Target} \\
\hline
Frame time budget & 11.1 ms (90 Hz) \\
Target resolution (per eye) & 1832×1920 pixels \\
Draw calls (Hub scene) & < 100 per frame \\
Texture memory budget & < 512 MB \\
Polygon count (visible) & < 100k triangles \\
\hline
\end{tabular}
\end{table}

\subsection{Rendering Optimizations}

\begin{itemize}
\item \textbf{Shared material instances}: Reduce draw calls by batching geometry with identical materials
\item \textbf{Texture compression}: ASTC 6×6 for UI elements, ASTC 4×4 for environment textures
\item \textbf{Single-pass instanced stereo}: Halves per-frame CPU work (both eyes in one draw call)
\item \textbf{Occlusion culling}: Disabled (scenes are spatially compact, overhead exceeds benefit)
\item \textbf{Dynamic batching}: Enabled for small meshes (< 300 vertices)
\end{itemize}

\subsection{Memory Management}

\begin{itemize}
\item Scene file sizes optimized (62--85 KB per scene)
\item Texture atlasing for UI sprites
\item Audio streaming for voice synthesis (no large audio caching)
\item Persistent GameObjects minimized (only transition manager, conversation history)
\end{itemize}

\subsection{Frame Time Breakdown}

Table~\ref{tab:frame_budget} shows typical frame time allocation in the Hub scene (most complex).

\begin{table}[h]
\centering
\caption{Frame Time Budget Breakdown (Hub Scene)}
\label{tab:frame_budget}
\begin{tabular}{lr}
\hline
\textbf{Component} & \textbf{Time} \\
\hline
Physics simulation & 1.2 ms \\
Script execution & 2.1 ms \\
Rendering (both eyes) & 5.8 ms \\
VR compositor overhead & 1.5 ms \\
Buffer margin & 0.5 ms \\
\hline
\textbf{Total} & \textbf{11.1 ms} \\
\hline
\end{tabular}
\end{table}

This allocation maintains the 11.1 ms frame budget required for consistent 90 Hz VR without reprojection artifacts (judder).
