\chapter{Orbital Physics Implementation}
\label{app:physics_implementation}

This appendix provides detailed technical specifications for the orbital physics simulation engine described in Section~\ref{subsec:physics_implementation}. All equations, algorithms, class methods, and numerical values are verified against the Unity project physics implementation.

\section{Two-Body Keplerian Mechanics}
\label{app:physics_keplerian}

The simulation implements two-body orbital mechanics under the following simplifying assumptions:

\begin{itemize}
\item Earth modeled as a point mass at the coordinate system origin
\item Satellite treated as a massless test particle (no gravitational influence on Earth)
\item No atmospheric drag, solar radiation pressure, or third-body perturbations
\item Instantaneous orbital maneuvers (no finite burn durations)
\end{itemize}

These assumptions yield closed-form Keplerian solutions suitable for educational visualization while maintaining physical accuracy for the mission profiles studied (ISS, Hubble, Voyager departure trajectory).

\section{Vis-Viva Equation Implementation}
\label{app:physics_visviva}

The vis-viva equation relates orbital velocity to position and total orbital energy. Table~\ref{tab:physics_constants} documents the physical constants used throughout the simulation.

\begin{table}[h]
\centering
\caption{Physical Constants for Orbital Calculations}
\label{tab:physics_constants}
\begin{tabular}{lrl}
\hline
\textbf{Constant} & \textbf{Value} & \textbf{Symbol} \\
\hline
Earth's standard gravitational parameter & 398,600 km³/s² & $\mu$ \\
Earth's mean radius & 6,371 km & $R_\oplus$ \\
Unity scale compression factor & 0.000785 Unity/km & $k$ \\
Unity Earth radius & 5 Unity units & $R_{\text{Unity}}$ \\
\hline
\end{tabular}
\end{table}

\subsection{Circular Orbit Calculation}

Circular orbits ($e = 0$) simplify the vis-viva equation to:

\begin{equation}
v_{\text{circular}} = \sqrt{\frac{\mu}{r}}
\label{eq:circular_velocity}
\end{equation}

where $r = R_\oplus + h$ is the orbital radius from Earth's center, and $h$ is the altitude above Earth's surface.

\paragraph{Implementation Method} The \texttt{OrbitController.CreateCircularOrbit()} method (lines 229--290) accepts altitude in kilometers and automatically calculates orbital velocity, eliminating user confusion between altitude and speed parameters. Algorithm~\ref{alg:circular_orbit} documents the calculation sequence.

\begin{table}[h]
\centering
\caption{Circular Orbit Calculation Algorithm}
\label{alg:circular_orbit}
\begin{tabular}{ll}
\hline
\textbf{Step} & \textbf{Calculation} \\
\hline
1. Validate altitude & $h_{\text{input}} \rightarrow \text{Clamp}(160, 35{,}786)$ km \\
2. Compute orbital radius & $r = R_\oplus + h = 6{,}371 + h$ km \\
3. Calculate orbital velocity & $v = \sqrt{\mu / r}$ km/s \\
4. Convert to Unity scale & $r_{\text{Unity}} = R_{\text{Unity}} + h \cdot k$ \\
5. Convert to angular velocity & $\omega = (v \cdot k) / r_{\text{Unity}}$ rad/s \\
\hline
\end{tabular}
\end{table}

\paragraph{Example: ISS Orbital Velocity} For the International Space Station at $h = 420$ km altitude:

\begin{align}
r &= 6{,}371 + 420 = 6{,}791 \text{ km} \\
v &= \sqrt{\frac{398{,}600}{6{,}791}} = 7.66 \text{ km/s} \\
\omega &= \frac{7.66 \times 0.000785}{5 + (420 \times 0.000785)} = 0.00111 \text{ rad/s}
\end{align}

This matches the real ISS orbital velocity of approximately 7.66 km/s.

\subsection{Elliptical Orbit Calculation}

Elliptical orbits ($0 < e < 1$) use the full vis-viva equation:

\begin{equation}
v = \sqrt{\mu \left(\frac{2}{r} - \frac{1}{a}\right)}
\label{eq:visviva_full}
\end{equation}

where $a$ is the semi-major axis and $r$ is the instantaneous distance from Earth's center.

\paragraph{Orbital Elements Derivation} Given periapsis altitude $h_p$ and apoapsis altitude $h_a$:

\begin{align}
r_p &= R_\oplus + h_p \quad \text{(periapsis radius)} \\
r_a &= R_\oplus + h_a \quad \text{(apoapsis radius)} \\
a &= \frac{r_p + r_a}{2} \quad \text{(semi-major axis)} \\
e &= \frac{r_a - r_p}{r_a + r_p} \quad \text{(eccentricity)}
\end{align}

\paragraph{Implementation Method} The \texttt{OrbitController.CreateEllipticalOrbit()} method (lines 300--367) computes velocity at periapsis using Equation~\ref{eq:visviva_full} with $r = r_p$:

\begin{equation}
v_p = \sqrt{\mu \left(\frac{2}{r_p} - \frac{1}{a}\right)}
\label{eq:periapsis_velocity}
\end{equation}

Table~\ref{tab:elliptical_constraints} documents parameter validation constraints enforced before calculation.

\begin{table}[h]
\centering
\caption{Elliptical Orbit Parameter Constraints}
\label{tab:elliptical_constraints}
\begin{tabular}{lr}
\hline
\textbf{Parameter} & \textbf{Constraint} \\
\hline
Periapsis altitude $h_p$ & 160--35,786 km \\
Apoapsis altitude $h_a$ & $h_p + 1$ km to 100,000 km \\
Eccentricity $e$ & $0 < e < 1$ (enforced implicitly) \\
Inclination $i$ & 0--180° \\
\hline
\end{tabular}
\end{table}

\section{Scale Compression}
\label{app:physics_scale}

The simulation implements logarithmic scale compression to fit orbital mechanics within the Meta Quest 3's comfortable rendering volume while preserving geometric relationships.

\subsection{Compression Factor Derivation}

Earth's physical radius (6,371 km) maps to 5 Unity units:

\begin{equation}
k = \frac{R_{\text{Unity}}}{R_\oplus} = \frac{5}{6{,}371} = 0.000785 \text{ Unity units/km}
\end{equation}

\paragraph{Example Mappings} Table~\ref{tab:scale_examples} shows real-world altitudes mapped to Unity rendering coordinates.

\begin{table}[h]
\centering
\caption{Scale Compression Examples}
\label{tab:scale_examples}
\begin{tabular}{lrr}
\hline
\textbf{Mission} & \textbf{Real Altitude (km)} & \textbf{Unity Altitude} \\
\hline
ISS & 420 & $420 \times 0.000785 = 0.33$ \\
Hubble & 540 & $540 \times 0.000785 = 0.42$ \\
Geostationary & 35,786 & $35{,}786 \times 0.000785 = 28.1$ \\
\hline
\end{tabular}
\end{table}

This compression maintains visual proportions: the ISS appears at $0.33 / 5 = 6.6\%$ of Earth's radius above the surface, matching the real ratio of $420 / 6{,}371 = 6.6\%$.

\subsection{Numerical Stability}

All physics calculations occur in real units (km, km/s) before conversion to Unity space for rendering. This ensures:

\begin{itemize}
\item No floating-point precision loss from working with very small Unity coordinates
\item Physical accuracy verifiable against published orbital data
\item Separation of physics (model) from rendering (view)
\end{itemize}

The \texttt{OrbitController} methods perform calculations in kilometers, then convert final results through multiplication by $k$ only when setting Unity Transform positions.

\section{Trajectory Visualization}
\label{app:physics_visualization}

The \texttt{OrbitVisualizer} class (280 lines) generates trajectory curves by sampling the orbital ellipse equation at discrete points and rendering through Unity's LineRenderer system.

\subsection{Orbital Ellipse Equation}

The orbit trajectory follows the polar equation:

\begin{equation}
r(\theta) = \frac{a(1 - e^2)}{1 + e \cos \theta}
\label{eq:orbit_polar}
\end{equation}

where $\theta$ is the true anomaly (angle from periapsis), $a$ is the semi-major axis, and $e$ is the eccentricity.

\subsection{Sampling Algorithm}

The \texttt{CalculateOrbitalPoint()} method (lines 217--231) samples Equation~\ref{eq:orbit_polar} at 128 evenly-spaced true anomaly angles $\theta \in [0, 2\pi)$. For each sample point:

\begin{align}
r &= \frac{a(1 - e^2)}{1 + e \cos \theta} \\
x &= r \cos(\theta + \omega) \\
z &= r \sin(\theta + \omega)
\end{align}

where $\omega$ is the argument of periapsis (orientation of the ellipse major axis in the orbital plane).

\paragraph{Inclination Transformation} The resulting planar coordinates undergo rotation by inclination angle $i$ via rotation matrix:

\begin{equation}
\mathbf{R}_i = \begin{bmatrix}
1 & 0 & 0 \\
0 & \cos i & -\sin i \\
0 & \sin i & \cos i
\end{bmatrix}
\label{eq:inclination_matrix}
\end{equation}

This tilts the orbital plane from equatorial (XZ) to the specified inclination angle, enabling visualization of polar orbits (ISS at 51.6°) and equatorial orbits (geostationary at 0°).

\subsection{Rendering Configuration}

Table~\ref{tab:linerenderer_config} documents the Unity LineRenderer configuration for optimal VR visibility.

\begin{table}[h]
\centering
\caption{LineRenderer Configuration Parameters}
\label{tab:linerenderer_config}
\begin{tabular}{ll}
\hline
\textbf{Parameter} & \textbf{Value} \\
\hline
Path resolution & 128 points \\
Line width & 0.05 Unity units \\
Color & Cyan (0, 1, 1) with 0.7 alpha \\
Shader & Sprites/Default (view-aligned billboarding) \\
Loop closure & Enabled (connects point 127 to point 0) \\
\hline
\end{tabular}
\end{table}

\paragraph{Special Cases}

\begin{itemize}
\item \textbf{Circular orbits} ($e = 0$): Simplify to constant radius $r = a$, producing perfect circles
\item \textbf{Elliptical orbits} ($0 < e < 1$): Render with visible eccentricity
\item \textbf{Debug visualization}: Green gizmo at periapsis, red gizmo at apoapsis for development testing
\end{itemize}

\section{Coordinate System Conventions}
\label{app:physics_coordinates}

The simulation uses Unity's left-handed coordinate system with the following conventions:

\begin{itemize}
\item \textbf{Origin}: Earth's center of mass
\item \textbf{Equatorial plane}: XZ plane ($y = 0$)
\item \textbf{Polar axis}: +Y direction points toward North Pole
\item \textbf{Reference direction}: +X axis defines 0° longitude
\item \textbf{Orbital motion}: Counterclockwise when viewed from above North Pole (right-hand rule)
\end{itemize}

This convention aligns with standard aerospace engineering practices while accommodating Unity's left-handed rendering system.
